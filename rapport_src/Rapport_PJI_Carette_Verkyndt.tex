\documentclass[pdftex,12pt,a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{setspace}
\usepackage[top=2.5cm,bottom=2.5cm,right=3cm,left=3cm]{geometry}
\usepackage{parskip}

\usepackage{hyperref}
\usepackage{color}

\usepackage{calc}
\usepackage{pseudocode}

\usepackage[pdftex]{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{fancybox}

\usepackage{caption}
\captionsetup{figurewithin=none}  
\captionsetup{tablewithin=none}

\AddThinSpaceBeforeFootnotes

\FrenchFootnotes

\newcommand{\HRule}{\rule{\linewidth}{1mm}}

\setlength{\parskip}{1mm}

\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
    \includegraphics[scale=0.6]{./img/univ-lille1.png}~\\[1.5cm]
    
    \textsc{\Large Master INFORMATIQUE}\\[0.5cm]
    
    \textsc{\Large Mention INFORMATIQUE}\\[2cm]

    \textsc{\LARGE Rapport de ProJet Encadré}\\[2cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries Analyse de Comportements avec Twitter\\[0.4cm] }

   \vfill

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        Antonin \textsc{Carette}\\
        Alexandre \textsc{Verkyndt}\\
      \end{flushleft}
    \end{minipage}
    
    \vfill

    % Bottom of the page
    {\large Promo 2014/2015}

  \end{center}
  \end{sffamily}
\end{titlepage}

\begin{spacing}{1.2}

\tableofcontents

\chapter*{Introduction}

\addcontentsline{toc}{chapter}{Introduction} 

\section{Problèmatique}

Le but de ce projet était de réaliser une application permettant d'analyser les comportements de tweets contenus dans l'application Twitter (en particulier, l'analyse de sentiments), via l'utilisation de son interface de programmation.\\
L'analyse de comportements sera étudié via différents algorithmes de classification (ou modèle), utilisant ou non une base d'apprentissage : le modèle basique (basé sur des dictionnaires), le modèle KNN et enfin le modèle Bayesien.

\section{Interface de programmation Twitter}

Pour ce projet, nous allons utiliser l'interface de programmation\footnote{Une interface de programmation est aussi appelée "API".} de Twitter.\\
Cette API nous permettra de récupérer les tweets voulus, sur un sujet donné, ainsi que toutes les informations suivantes : l'ID du tweet, l'émetteur, s'il s'agit d'un tweet original ou s'il s'agit d'un \textit{retweet}\footnote{Un \textit{retweet} est un tweet partagé - il n'est alors en aucun cas original.}.\\
Aussi, nous allons utiliser cette interface via la librairie Java \textit{Twitter4J}, dans sa version stable. En effet, cette librairie (à jour en fonction des mises à jour de l'interface de programmation) Java nous permettra d'accéder facilement aux tweets recueillis ainsi qu'aux informations du tweet, via des classes et des méthodes Java programmées.

\chapter{Présentation du logiciel}

\section{Généralités}

Ce programme a été écrit avec Java et Swing, pour la partie Interface Utilisateur.
\\
Suite à l'utilisation de fonctions avancées telles que le \textit{switch} sur une chaîne de caractères, ou le \textit{cast} des JComboBox, ce programme n'est compatible qu'avec une Machine Virtuelle Java de version 7 et plus.

\subsection{Titre et logo}

Notre logiciel se nomme \textit{BehAnTweet}\footnote{La documentation développeur du logiciel est présente dans le répertoire \textit{\textbf{doc}}, à partir de la racine du projet.}. Le nom du logiciel se réfère à une phrase anglaise "Behavior Analysis of a Tweet", littéralement "Analyse de Comportement d'un Tweet", sujet du projet encadré.
\\
Le logo du logiciel est, quant à lui, une référence à \textit{Bahamut}\footnote{Un poisson (ou serpent géant), présent dans la mythologie Arabe.}, sous licence libre.

\subsection{Logiciels de versioning}

Git a été utilisé comme logiciel de versioning principal, dû à sa simplicité d'emploi, à la durée d'utilisation faite de celui-ci depuis plusieurs mois ainsi que grâce à l'application interactive Github\footnote{https://github.com/WebTogz/BehAnTweet}.\\
Svn a lui été utilisé pour transmettre la version principale du logiciel sur les serveurs de l'Université, toutes les 3 semaines, afin de pouvoir visualiser l'avancement du projet régulièrement.

\section{Description de l'architecture de l'application}

Nous avons utilisé le modèle \textbf{MVC} (pour Modèle - Vue - Contrôleur) pour notre projet.\\
Ce modèle, très connu pour le développement logiciel, est destiné à répondre aux besoins des applications interactives, en séparant les problématiques liées aux différents composants au sein de leur architecture respective.\\
Aussi, le gros bénéfice de ce patron est qu'il permet facilement l'évolution de l'application par la suite, via l'ajout de classes dans les packages spécifiques suivants: \textbf{Controler}, \textbf{Model}, \textbf{View}.

\subsection{Packaging}

\subsubsection{Controler}

Le contrôleur prend en charge la gestion des événements de synchronisation pour mettre à jour la vue ou le modèle, et les synchroniser. Il analyse la requête du client et se contentera alors renvoyer la vue correspondant à la demande, en fonction du modèle appelé. Aussi, il est important de savoir que le contrôleur n'effectue aucun traitement, et ne modifie aucunement les données!
\\
Il était ainsi nécessaire d'implémenter le patron \textbf{Observable/Observeur}, afin de pouvoir un Observer (objet qui observe) qu'une modification a été apporté sur un Observable (objet observé par un Observer).

\subsubsection{Model}

Le modèle est le coeur algorithmique de l'application - il gère le traitement des données, la modification des vues mais aussi les interactions avec la base de données.
\\
Le package Model contiendra tous les modèles de l'application - chaque modèle (à part la base Model.java) contiendra sa propre implémentation d'un algorithme de classification (Dictionnaire, KNN, Bayes).

\subsubsection{View}

La vue est le coeur de l'intéraction avec l'application.
\\
Elle détient plusieurs tâches à effectuer:
\begin{itemize}
\item{la première est de présenter les résultats renvoyés par le modèle,}
\item{la seconde est de recevoir l'action de l'utilisateur - via la manipulation de boutons, objets cliquables, etc...}
\end{itemize}
Toutes ces tâches, une fois finalisées, seront renvoyées au Contrôleur de l'application afin de pouvoir être traitées par le modèle.

\section{Interface graphique}

Nous avons pensé avant tout à une utilisation simple du logiciel, reposant sur une seule fenêtre. Cette fenêtre contiendra tous les paramètres pouvant être manipulés par l'utilisateur (le nombre de tweets à recueillir, l'algorithme utilisé et ses spécifications), une barre de recherche concernant un sujet donné, et enfin un grand espace dédié à la liste des tweets recueillis et de leur classification par l'algorithme choisi.

\subsection{Captures d'écran}

\subsection{Manuel d'utilisation}

\chapter{Algorithmes de classification}

Pour l'analyse de tweets, divers algorithmes de classification ont été utilisés.\\
Voici la liste des algorithmes de classification utilisés.

\section{Dictionnaire}

L'algorithme \textbf{Dictionnaire} est l'algorithme le plus facile à programmer.\\
En effet, il consiste dans un premier temps à obtenir une liste de mots positifs et négatifs. Chaque tweet sera découpé en mots, et chaque mot sera confondu avec les deux listes - aussi, le tweet partira avec un score entier nul. Si un des mots du tweet est reconnu dans la liste de mots positifs, on diminuera son score - à contrario, si ce mot est reconnu dans la liste de mots négatifs, on augmentera son score.\\
Finalement, on obtiendra pour un tweet un score, somme des scores de chaque mot appartenant à celui-ci. Ce score décidera de la classification auquel appartient le tweet:
\begin{itemize}
\item{positif, si le score est négatif,}
\item{indéterminé, si le score est nul,}
\item{négatif, si le score est positif.}
\end{itemize}
La critique première qui peut être faite pour cette méthode de classification est qu'il est nécessaire de donner tous les mots possibles pour classifier un tweet - aussi, cette méthode ne gère pas le cynisme, ironie et sarcasme des tweets, car cet algorithme ne travaille pas sur une base d'apprentissage.

\section{KNN}

La méthode KNN, ou des \textit{k} plus proches voisins, est une méthode d'apprentissage automatique.\\
Cette méthode consistera, pour chaque tweet recueilli, à calculer sa ressemblance avec tous les autres tweets recueillis, et ainsi former des groupes de ressemblance. Ainsi, un score sera établi en fonction du nombre de mots en commun entre ceux-ci. Si ce score est confortant, le tweet à classifier sera sauvé dans le même groupe que les tweets comparés, appartenant déjà à un groupe, sinon le tweet sera affecté dans un nouveau groupe. Ainsi, nous pourrons avoir au minimum 1 groupe de tweets, mais au maximum \textit{n} groupes, où \textit{n} est le nombre de tweets recueillis lors d'une recherche.\\
Une fois ces groupes établis, nous utiliserons donc les dictionnaires pré-établis afin de calculer la classification de chaque tweet pour un groupe - la classification du groupe se fera alors quant à la moyenne des scores de chaque tweet.

\section{Bayes}

Pour la méthode Bayes, nous utiliserons deux sous-méthodes de classification: \textit{Présence} et \textit{Fréquence}.

\subsection{Présence}

\subsection{Fréquence}

\chapter{Résultats de la classification}

\chapter{Conclusion}

\chapter*{Bibliographie - Webographie}

\end{spacing}
\end{document}